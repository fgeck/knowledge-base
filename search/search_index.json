{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to fgeck's Knowledge","text":"<p>This documentation is intended to serve as my own public knowledge base for all topics related to coding and technical problems I encounter during my day to day work.</p>"},{"location":"intellij/","title":"IntelliJ","text":""},{"location":"intellij/#run-configurations","title":"Run Configurations","text":""},{"location":"intellij/#autoformatting-kotlin-code","title":"Autoformatting Kotlin Code","text":"<ul> <li>recommended in general: ktlint</li> <li>either use gradle plugin</li> <li>used ktlint ruleset version can be found here:</li> </ul> <pre><code>configure&lt;org.jlleitschuh.gradle.ktlint.KtlintExtension&gt; {\n    version.set(\"1.0.1\")\n    ...\n}\n</code></pre> <ul> <li>or use ktlint-intellij-pluign</li> <li>Used ktlint ruleset version can be configured in plugin settings</li> <li>PRO: can automatically fix all issues on the fly</li> </ul>"},{"location":"k8s-docker/","title":"Kubernetes &amp; Docker","text":""},{"location":"kotlin/","title":"Kotlin, Java &amp; Gradle","text":""},{"location":"kotlin/coroutines/","title":"Kotlin Coroutines","text":"<p>Coroutines behave like Threads but they are not Threads. They can be called lightweight Threads. When a Coroutine sleeps the coroutine will be slept but the Thread will be freed up again. After the sleep the Coroutine continue may in another Thread. You can run millions of Coroutines, but not millions of Threads.</p>"},{"location":"kotlin/coroutines/#logging-with-slf4j","title":"Logging with SLF4J","text":"<p>Logging is quite simple but needs to be considered when launching coroutines. Reference can be found here</p> <pre><code>MDC.put(\"kotlin\", \"rocks\") // Put a value into the MDC context\n\nlaunch(MDCContext()) {\n    logger.info { \"...\" }   // The MDC context contains the mapping here\n}\n------------\n// problematic\nlaunch(MDCContext()) {\n    MDC.put(\"key\", \"value\") // This update will be lost\n    delay(100)\n    println(MDC.get(\"key\")) // This will print null\n}\n------------\n// solution\nlaunch(MDCContext()) {\n    MDC.put(\"key\", \"value\") // This update will be captured\n    withContext(MDCContext()) {\n        delay(100)\n        println(MDC.get(\"key\")) // This will print \"value\"\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#coroutine-scope-and-context","title":"Coroutine Scope and Context","text":""},{"location":"kotlin/coroutines/#scope","title":"Scope","text":"<ul> <li>a coroutine must always be started in a scope</li> <li>Cancelling a scope cancels all coroutines running in that scope</li> </ul> <pre><code>fun main() = runBlocking {\n    val scope = CoroutineScope(Dispatchers.Default)\n\n    val job = scope.launch {\n        delay(1000L)\n        println(\"Task completed!\")\n    }\n\n    delay(500L)\n    scope.cancel()\n    println(\"Scope canceled\")\n}\n</code></pre>"},{"location":"kotlin/coroutines/#context","title":"Context","text":"<ul> <li>define behavior of coroutines</li> <li>contains elements (dispatchers, job objects) for configuration of coroutine execution</li> <li>is an indexed set of elements where each element in the set has a unique key</li> <li>contexts can be combined</li> </ul> <p>Combine a dispatcher + coroutine name:</p> <pre><code>fun main() = runBlocking {\n    val context = Dispatchers.Default + CoroutineName(\"ExampleCoroutine\")\n\n    val job = launch(context) {\n        println(\"Coroutine context: $coroutineContext\")\n        delay(1000L)\n        println(\"Task completed!\")\n    }\n\n    job.join()\n}\n</code></pre> <p>Use a SupervisorJob to make child coroutines independent, so that if one child coroutine fails, it doesn't cause the others to be canceled:</p> <pre><code>fun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    val scope = CoroutineScope(coroutineContext + supervisor)\n\n    val job1 = scope.launch {\n        delay(500L)\n        println(\"Task 1 completed\")\n    }\n\n    val job2 = scope.launch {\n        delay(1000L)\n        throw RuntimeException(\"Task 2 failed\")\n    }\n\n    val job3 = scope.launch {\n        delay(1500L)\n        println(\"Task 3 completed\")\n    }\n\n    try {\n        joinAll(job1, job2, job3)\n    } catch (e: Exception) {\n        println(\"Caught exception: $e\")\n    }\n    supervisor.cancel()\n}\n</code></pre>"},{"location":"kotlin/coroutines/#forkjoin-equivalent","title":"Fork/Join equivalent","text":"<ul> <li>use <code>val x async  { }; x.await()</code> to launch something async and wait for it</li> </ul>"},{"location":"kotlin/coroutines/#launching-coroutines","title":"Launching coroutines","text":"<pre><code>// Using threads\nthread {\n    sleep(1000)\n    println(\"World\")\n}\n\nprint(\"Hello, \")\nThread.sleep(1500)\n\n// Using launch\nlaunch {\n    delay(1000)             // does not block thread. Only sleeps the coroutine\n    // Thread.sleep(1000)   // we can block the main Thread from a coroutine\n    println(\"World\")\n}\n\nprint(\"Hello, \")\nThread.sleep(1500)          // blocks main thread\n</code></pre> <p><code>launch{}</code> launches the code async immediately. Instead of <code>Thread.sleep</code> we use <code>delay</code>.</p>"},{"location":"kotlin/coroutines/#functions-and-coroutine-builders","title":"Functions and Coroutine Builders","text":""},{"location":"kotlin/coroutines/#launch","title":"Launch","text":"<ul> <li>Coroutines have to be run inside a context</li> <li>some funcs can only be called inside coroutines (e.g. <code>delay()</code>). To let the compiler know that this func can only be called in a coroutine we mark them with <code>suspend</code></li> <li><code>launch{}</code> runs the code immediately in a coroutine without waiting for it</li> </ul>"},{"location":"kotlin/coroutines/#runblocking","title":"RunBlocking","text":"<ul> <li><code>runBlocking{}</code> runs the code inside but waits for it to finish. Can be used to make the whole main func to run in a coroutine and wait for it</li> <li>can be used in tests</li> </ul> <pre><code>suspend fun doWork() {}\n\nclass SimpleTest {\n    @Test\n    fun aTest() = runBlocking {\n        dowork()\n        assertEquals()\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#waiting-join-to-cancel-coroutines","title":"Waiting, Join-to, Cancel Coroutines","text":""},{"location":"kotlin/coroutines/#waiting","title":"Waiting","text":"<ul> <li>Join: calling code blocks until coroutine is finished. <code>launch{}</code> returns <code>Job</code> which has a <code>join()</code> func.</li> </ul> <pre><code>val job = launch {delay(1000); println(\"World\")}\nprintln(\"Hello\")\njob.join()\n</code></pre>"},{"location":"kotlin/coroutines/#cancellation","title":"Cancellation","text":"<ul> <li>We must check if a coroutine is cancellable. This has to be checked in a suspending func. This is called cooperative. All built-in funcs are cooperative. Either our suspend func calls a built-in suspend func, or explicitly check if in the job state</li> </ul> <pre><code>val job = launch {\n    delay(10)\n    println(\".\")\n    // Thread.sleep(1)      &lt;- this would not cancel as it is not cooperative\n}\ndelay(2500)\njob.cancel()        // request cancellation\njob.join()          // wait for cancellation to happen\nprintln(\"finally done\")\n// fast way\njob.cancelAndJoin()\n</code></pre> <ul> <li>we can check the cancellation via <code>isActive</code> inside CoroutineScopes</li> <li> <ol> <li><code>yield()</code> can check in a coroutine if we are cancelled and eventually cancel</li> </ol> </li> <li> <ol> <li>check actively via <code>if(!isActive)</code></li> </ol> </li> </ul> <p>In our own code:</p> <pre><code>// 1\nval job = launch {\n    delay(10)\n    println(\".\")\n    yield()     // checks for cancellation and may cancel\n    Thread.sleep(11111)\n}\n// 2\nval job = launch {\n    delay(10)\n    println(\".\")\n    if(!isActive) throw CancellationException // or: reaturn@launch\n    Thread.sleep(11111)\n}\n</code></pre>"},{"location":"kotlin/coroutines/#handle-exceptions","title":"Handle Exceptions","text":"<ul> <li>Nice for closing resources: wrap async code in try/catch, on CancellationException close resources. This must be non cancellable.</li> <li>we can pass Exceptions to cancel(), but if they are not caught we will kill the app. Never use anything else than <code>CancellationException</code> as a reason for <code>cancel()</code></li> </ul> <pre><code>try {\n    val job = launch {\n        delay(10)\n        println(\".\")\n        yield()     // checks for cancellation and may cancel\n        Thread.sleep(11111)\n    }\n} catch(ex: CancellationException) {\n    println(\"Cancelled\")\n} finally {\n    run(NonCancellable) { // now this is not cancellable by another coroutine\n        println(\"Finally\")\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#timeouts","title":"Timeouts","text":"<pre><code>val job = withTimeoutOrNull(100) {\n    delay(10)\n    println(\".\")\n    yield()     // checks for cancellation and may cancel\n    Thread.sleep(11111)\n}\nif(job == null) {\n    println(\"timedout\")\n}\ndelay(1000)\n</code></pre>"},{"location":"kotlin/coroutines/#coroutine-contexts","title":"Coroutine Contexts","text":"<ul> <li>all coroutines run as part of context, defined by launcher</li> <li>context can flow to child coroutines</li> <li>contexts can be joined</li> </ul>"},{"location":"kotlin/coroutines/#launch-in-different-contexts","title":"Launch in different contexts","text":"<pre><code>// default\njobs += launch{}\n// default\njobs += launch(DefaultDispatcher){}\n// not confined -&gt; main thread or where parent was started\njobs+= launch(Unconfined){}\n// context of parent (e.g. runBlocking)\njobs += launch(coroutineContext){}\n// ForkJoinPool.commonPool\njobs += launch(CommonPool){}\n// dedicated thread (expensive operation and thread has to be managed)\njobs += launch(newSingleThreadContext(\"myThread\")){}\n</code></pre> <ul> <li><code>Unconfined</code> starts in the thread of parent but once a suspending func was called it may continues in another thread</li> <li>use <code>newSingleThreadContext</code> *always- with <code>use{}</code> so that it is always closed: <code>newSingleThreadContext(\"mySTC\").use{}</code></li> </ul>"},{"location":"kotlin/coroutines/#access-coroutines","title":"Access coroutines","text":"<ul> <li><code>coroutineContext</code> is available in coroutines</li> </ul> <pre><code>val job = launch {\n    println(\"IsActive: ${coroutineContext[job.Key]!!.isActive}\")\n}\njob.join()\n</code></pre>"},{"location":"kotlin/coroutines/#parents-childs","title":"Parents - Childs","text":"<pre><code>val outer = launch{\n    launch(coroutineContext) { // &lt;---pass context to child\n        repeat(1000) {\n            print('.')\n            delay(1)\n        }\n    }\n}\nouter.join() // &lt;--- wait on outer coroutine which waits for the inner coroutine\nouter.cancelAndJoin() // &lt;--- cancels both due to relationship\nouter.cancelChildren() // &lt;--- cancel only childs\nprintln('finished')\n</code></pre> <ul> <li>when children are cancelled, exceptions are propagated to parent</li> </ul>"},{"location":"kotlin/coroutines/#combine-coroutines","title":"Combine Coroutines","text":"<ul> <li>contexts are maps and can be combined</li> <li>keys will be overridden</li> <li>missing keys are not added</li> <li>order may be important</li> </ul> <pre><code>runBlocking {\n    val job = launch(CoroutineName(\"myCoroutine\")+ coroutineContext)\n}\n</code></pre>"},{"location":"kotlin/coroutines/#get-data-from-coroutines-compose-funcs","title":"Get Data from Coroutines &amp; compose funcs","text":"<ul> <li>launch builder starts coroutine and returns job</li> <li>async coroutine builder returns Deferred which can be used later. Deferred inherits from Job</li> </ul> <pre><code>suspend doSth1(): Int {\n    delay(100)\n    println(\"working 1\")\n    return Random(System.currentTimeMillis()).nextInt(42)\n}\n\nsuspend doSth2(): Int {\n    delay(200)\n    println(\"working 2\")\n    return Random(System.currentTimeMillis()).nextInt(42)\n}\n\nfun main(args: Array&lt;String&gt;) {\n    val job = launch {\n        // start both async, wait for both\n        val r1:Deferred&lt;Int&gt; = async{ doSth1() }\n        val r2 = async{ doSth2() }\n        println(\"result ${r1.await() + r2.await()}\")\n    }\n    job.join()\n}\n</code></pre> <ul> <li>async jobs run concurrently. If we wait for them we block until this async is done</li> </ul>"},{"location":"kotlin/coroutines/#define-an-async-func","title":"Define an async func","text":"<pre><code>fun main(args: Array&lt;String&gt;) {\n    val result = doWorkAsync(\"wasd\")\n    runBlocking { // we need to setup a coroutine to access the Deferred values\n        println(result.await())\n    }\n}\n\n// not a suspend func, but using coroutine builder\nfun doWorkAsync(msg: String): Deferred&lt;Int&gt; = async {\n        println(msg)\n        delay(100)\n        return@async 42\n    }\n</code></pre>"},{"location":"kotlin/coroutines/#lazy-evaluations","title":"Lazy evaluations","text":"<pre><code>fun main(args: Array&lt;String&gt;) {\n    val job = launch {\n        val result = async(coroutineContext){ doWorkLazy(\"wasd\") } // define as child, so that main coroutine waits\n        println(\"Result: ${result.await()}\")\n        val result2 = async(start = CoroutineStart.LAZY) { doWorkLazy(\"wasd\") } // this is only started when await is called!!!!\n    }\n    job.join()\n}\n\n// not a suspend func, but using coroutine builder\nsuspend fun doWorkLazy(msg: String): Int {\n        println(msg)\n        delay(100)\n        return 42\n    }\n</code></pre>"},{"location":"kotlin/coroutines/#channels-for-in-coroutine-communication","title":"Channels for in-coroutine-communication","text":"<ul> <li>you can send/receive to/from a channel</li> <li>channels block</li> <li>can create buffer channels</li> <li>need to know when channel has finished</li> </ul> <pre><code>fun main(args: Array&lt;String&gt;) {\n    val channel = Channel&lt;Int&gt;()\n\n    val job = launch {\n        for(x in 1..5) {\n            print(\"send $x\")\n            channel.send(x) // channel is then blocked until someone receives the value\n        }\n        // always close a channel\n        channel.close()\n    }\n    // not so good as we must know how many items will be sent to the channel\n    repeat(4) {\n        println(\"receive\" ${channel.receive()}) // unblocks channel so that next item can be send; receive blocks as well. If we want to receive sth. but channel is empty the code waits/blocks until sth. is received\n    }\n    // better approach\n    for(y in channel) {\n        println(\"receive\" $y)\n    }\n\n    job.join()\n}\n</code></pre>"},{"location":"kotlin/coroutines/#make-code-above-easier-with-built-in-producerjob","title":"Make code above easier with built-in <code>ProducerJob</code>","text":"<pre><code>fun produceNumbers(): ProducerJob&lt;Int&gt; = produce {\n    // we are already in a coroutine here\n    for(x in 1..5) {\n        println(\"send $x\")\n        send(x)\n    }\n    println(\"done\")\n}\n\nfun main(args: Array&lt;String&gt;) {\n    val channel = produceNumbers()\n\n    channel.consumeEach{\n        println(it)\n    }\n    println(\"Main done\")\n}\n</code></pre>"},{"location":"kotlin/coroutines/#pipelining-data-from-one-coroutine-to-another","title":"Pipelining data from one coroutine to another","text":"<pre><code>fun produceNumbers(): ProducerJob&lt;Int&gt; = produce {\n    // we are already in a coroutine here\n    val x = 1\n    while(true) {\n        send(x++)\n    }\n}\n\nfun produceSquareNumbers(numbers: ReceiveChannel&lt;Int&gt;): ProducerJob&lt;Int&gt; = produce {\n    // we are already in a coroutine here\n    for (x in numbers) {\n        send(x*x)\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val producer = produceNumbers()\n    val square = produceSquareNumbers(producer)\n\n    for(i in 1..5) {\n        println(square.receive())\n    }\n    square.cancel()\n    producer.cancel()\n    println(\"Main done\")\n}\n</code></pre>"},{"location":"kotlin/coroutines/#multiple-consumers-fan-out","title":"Multiple consumers / fan-out","text":"<pre><code>fun produceNumbers() = produce&lt;Int&gt; {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\nfun consumer(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch {\n    channel.consumeEach {\n        println(\"Processor #$id received $it in thread ${Thread.currentThread().name}\")\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val producer = produceNumbers()\n    repeat(5) { consumer(it, producer) }\n    println(\"launched\")\n    delay(950)\n    producer.cancel() // cancel producer coroutine and thus kill them all\n}\n</code></pre>"},{"location":"kotlin/coroutines/#fan-in","title":"Fan-In","text":"<pre><code>suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, interval: Long) {\n    while (true) {\n        delay(interval)\n        channel.send(s)\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val channel = Channel&lt;String&gt;()\n    launch(coroutineContext) { sendString(channel, \"foo\", 200L) }\n    launch(coroutineContext) { sendString(channel, \"BAR!\", 500L) }\n    repeat(6) { // receive first six\n        println(channel.receive())\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n}\n</code></pre>"},{"location":"kotlin/coroutines/#buffered-channels-channels-which-do-not-block-until-buffer-is-full","title":"Buffered Channels (channels which do not block until buffer is full)","text":"<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val channel = Channel&lt;Int&gt;(4) // create buffered channel\n    val sender = launch(coroutineContext) {\n        // launch sender coroutine\n        repeat(10) {\n            println(\"Sending $it\") // print before sending each element\n            channel.send(it) // will suspend when buffer is full\n        }\n    }\n    // don't receive anything... just wait....\n    delay(1000)\n    launch { repeat(10) { println(\" --Receiving ${channel.receive()}\") } }\n    sender.cancel() // cancel sender coroutine\n}\n</code></pre>"},{"location":"kotlin/coroutines/#fairness-of-channels","title":"Fairness of Channels","text":"<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val discusison = Channel&lt;Comment&gt;()\n\n    launch(coroutineContext) { child(\"he did it\", discussion)}\n    launch(coroutineContext) { child(\"she did it\", discussion)}\n\n    discussion.send(Comment(0))\n    delay(1000)\n    coroutineContext.cancel()\n}\n\nsuspend fun child(text: String, discussion: Channel) {\n    for(comment in discussion) {\n        comment.count++\n        println(\"$text $comment\")\n        delay(300)\n        discussion.send(comment)\n    }\n}\n</code></pre> <ul> <li>when running this code we will see that every coroutine gets the same amount</li> </ul>"},{"location":"kotlin/coroutines/#load-balancing-channels-fan-in-and-fan-out","title":"Load Balancing Channels - Fan-in and Fan-out","text":"<pre><code>data class Work(var x: Long = 0, var y: Long = 0, var z: Long = 0)\n\nval numberOfWorkers = 10\nvar totalWork = 20\nval finish = Channel&lt;Boolean&gt;()\n\nvar workersRunning = AtomicInteger()\n\nsuspend fun worker(input: Channel&lt;Work&gt;, output: Channel&lt;Work&gt;) {\n\n    workersRunning.getAndIncrement()\n    for (w in input) {\n        w.z = w.x - w.y\n        delay(w.z)\n        output.send(w)\n    }\n    workersRunning.getAndDecrement()\n    if(workersRunning.get() === 0)\n    {\n        output.close()\n        println(\"Closing output\")\n    }\n}\n\nfun run() {\n    val input = Channel&lt;Work&gt;()\n    val output = Channel&lt;Work&gt;()\n\n    println(\"Launch workers\")\n    repeat (numberOfWorkers) {\n        launch { worker(input, output) }\n    }\n    launch { sendLotsOfWork(input) }\n    launch { receiveLotsOfResults(output) }\n}\n\nsuspend fun receiveLotsOfResults(channel: Channel&lt;Work&gt;) {\n\n    println(\"receiveLotsOfResults start\")\n\n    for(work in channel) {\n        println(\"${work.x}*${work.y} = ${work.z}\")\n    }\n    println(\"receiveLotsOfResults done\")\n    finish.send(true)\n}\n\nsuspend fun sendLotsOfWork(input: Channel&lt;Work&gt;) {\n    repeat(totalWork) {\n        input.send(Work((0L..100).random(), (0L..10).random()))\n    }\n    println(\"close input\")\n    input.close()\n}\n\nfun main(args: Array&lt;String&gt;) {\n    run()\n    runBlocking { finish.receive() }\n    println(\"main done\")\n}\n\nprivate object RandomRangeSingleton : Random()\n\n\nfun ClosedRange&lt;Long&gt;.random() = (RandomRangeSingleton.nextInt((endInclusive.toInt() + 1) - start.toInt()) + start)\n</code></pre>"},{"location":"kotlin/coroutines/#waiting-on-multiple-coroutines-using-select","title":"Waiting on multiple coroutines using select","text":""},{"location":"kotlin/coroutines/#simple-select","title":"Simple Select","text":"<ul> <li>allow multiple channels to be awaited on</li> <li>select is biased to first channel in list</li> </ul> <pre><code>fun producer1() = produce{\n    while(true) {\n//        delay(200)\n        send(\"from producer 1\")\n    }\n}\n\nfun producer2() = produce{\n    while(true) {\n//        delay(300)\n        send(\"from producer 2\")\n    }\n}\n\nsuspend fun selector(message1: ReceiveChannel&lt;String&gt;, message2: ReceiveChannel&lt;String&gt;) {\n    select&lt;Unit&gt; {\n        message1.onReceive { value -&gt; // in case there is a receive here it will always be executed\n            println(value)\n        }\n        message2.onReceive { value -&gt;\n            println(value)\n        }\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val m1 = producer1()\n    val m2 = producer2()\n\n    repeat(15) {\n        selector(m1, m2)\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#select-with-closed-channels","title":"Select with closed Channels","text":"<ul> <li>use <code>onReceiveOrNull</code></li> </ul> <pre><code>suspend fun selector(message1: ReceiveChannel&lt;String&gt;, message2: ReceiveChannel&lt;String&gt;): String {\n    select&lt;String&gt; {\n        message1.onReceiveOrnUll { value -&gt;\n            value ?: \"Channel 1 is closed \"\n        }\n        message2.onReceiveOrnUll { value -&gt;\n            value ?: \"Channel 2 is closed \"\n        }\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#use-side-channels","title":"Use side Channels","text":"<ul> <li>for non blocking send</li> <li>polling is possible</li> <li>timeout is possible</li> </ul> <pre><code>fun produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; {\n    for (num in 1..10) {\n        delay(100)\n        select&lt;Unit&gt; {      // if I can send to one channel -&gt; send it\n            onSend(num){}\n            side.onSend(num){}\n        }\n    }\n    println(\"Done sending\")\n}\n\nfun main1(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n\n    val side = Channel&lt;Int&gt;()\n\n    launch { side.consumeEach { println(\"side $it\") }}\n\n    val producer = produceNumbers(side)\n\n    producer.consumeEach {\n        println(\"$it\")\n        delay(500)\n    }\n}\n</code></pre> <ul> <li>result will be that most is consumed from side channel</li> </ul>"},{"location":"kotlin/coroutines/#timeout","title":"Timeout","text":"<pre><code>fun producer() = produce {\n    var i = 0\n    while(True) {\n        delay(5000)\n        send(i++)\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    var msg = producer()\n    select&lt;Unit&gt; {\n        msg.onReceive {\n            println(it)\n        }\n        onTimeout(4000) {\n            println(\"timed out\")\n        }\n    }\n}\n</code></pre>"},{"location":"kotlin/coroutines/#actors","title":"Actors","text":"<ul> <li>lightweight processes</li> <li>no shared state</li> <li>can communicate via messages</li> <li>are channels with state</li> <li>can protect data</li> <li>no state shared -&gt; no locks needed</li> <li>3 parts: coroutine, state, messages</li> </ul>"},{"location":"kotlin/coroutines/#actor-to-increment-a-counter-safely","title":"Actor to increment a counter safely","text":"<pre><code>suspend fun run(context: CoroutineContext, numberOfJobs: Int, count: Int, action: suspend () -&gt; Unit): Long {\n    // action is repeated by each coroutine\n    return measureTimeMillis {\n        val jobs = List(numberOfJobs) {\n            launch(context) {\n                repeat(count) { action() }\n            }\n        }\n        jobs.forEach { it.join() }\n    }\n}\n\nsealed class CounterMsg\nobject InitCounter : CounterMsg()\nobject IncCounter : CounterMsg()\nclass GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg()\n\nfun counterActor() = actor&lt;CounterMsg&gt; {\n    var counter = 0\n    for(msg in channel) {\n        when(msg) {\n            is InitCounter -&gt; counter = 0\n            is IncCounter -&gt; counter++\n            is GetCounter -&gt; msg.response.complete(counter)\n        }\n    }\n}\n\nfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {\n    val jobs = 100\n    val count = 10000\n\n    val counter = counterActor()\n\n    counter.send(InitCounter)\n\n    val time = run(CommonPool, jobs, count) {\n        counter.send(IncCounter)\n    }\n\n    var response = CompletableDeferred&lt;Int&gt;()\n    counter.send(GetCounter(response))\n\n    println(\"Completed ${jobs * count} actions in $time ms\")\n    println(\"result is ${response.await()}\")\n}\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n</code></pre>"},{"location":"kotlin/java-async/","title":"Async Programming in Java","text":""},{"location":"kotlin/java-async/#executorservice-pattern","title":"ExecutorService Pattern","text":"<pre><code>ExecutorService service = Executors.newFixedThreadPool(4);\nHttpClient client = ...;\nFuture&lt;String&gt; future = service.submit(() -&gt; client.get(\"https://google.com\"));\nString resp = future.get();\n</code></pre>"},{"location":"kotlin/java-async/#completablefuture","title":"CompletableFuture","text":"<pre><code>Supplier&lt;String&gt; fetchA = () -&gt; {return client.get(\"https://google.com\")} ;\nSupplier&lt;String&gt; fetchB = () -&gt; {return client.get(\"https://google.com\")} ;\nList&lt;Supplier&lt;String&gt; suppliers = List.of(fetchA, fetchB);\nList&lt;CompletableFuture&lt;String&gt;&gt; allFutures = new ArrayList();\nfor (Supplier&lt;String&gt; s : suppliers) {\n    CompletableFuture&lt;String&gt; c = CompletableFuture.supplyAsync(s)\n    allFutures.add(c);\n}\nfor (CompletableFuture&lt;String&gt; c : allFutures) {\n    c.get(); // can throw exception ; or use join() for no exception\n}\n</code></pre>"},{"location":"kotlin/java-async/#task-pipelining","title":"Task Pipelining","text":"<ul> <li>via <code>thenApply()</code></li> </ul> <pre><code>CompletableFuture&lt;String&gt; getA = CompletableFuture.supplyAsync( () -&gt; doWork() );\nCompletableFuture&lt;String&gt; getB = getA.thenApply(\n    it -&gt; doWork()\n);\n</code></pre> <pre><code>Collection&lt;String&gt; allResults = new ConcurrentLinkedDeque&lt;&gt;();\n\nSupplier&lt;String&gt; fetchA = () -&gt; {return client.get(\"https://google.com\")} ;\nSupplier&lt;String&gt; fetchB = () -&gt; {return client.get(\"https://google.com\")} ;\nList&lt;Supplier&lt;String&gt; suppliers = List.of(fetchA, fetchB);\nList&lt;CompletableFuture&lt;String&gt;&gt; allFutures = new ArrayList();\nfor (Supplier&lt;String&gt; s : suppliers) {\n    CompletableFuture&lt;String&gt; c = CompletableFuture.supplyAsync(s);\n    allFutures.add(c);\n}\n\nList&lt;CompletableFuture&lt;String&gt;&gt; voidFutures = new ArrayList();\nfor (CompletableFuture&lt;String&gt; c : allFutures) {\n    CompletableFuture&lt;Void&gt; voids = c.thenAccept(System.out::println);\n    voidFutures.add(voids);\n    c.thenAccept(allResults::add);\n}\n\n// app would die here, therefore we need the join()\nfor(CompletableFuture&lt;void&gt; v : voidFutures) {\n    v.join();\n}\n</code></pre>"},{"location":"kotlin/java-async/#async-composition","title":"Async Composition","text":""},{"location":"kotlin/java-async/#use-the-first-that-finishes-anyof-use-all-allof","title":"Use the first that finishes <code>anyOf()</code> Use all <code>allOf()</code>","text":"<ul> <li><code>CompletableFuture.anyOf(a, b, c)</code> can be used</li> <li>due to <code>CompletableFuture&lt;Object&gt;</code> casting is needed</li> </ul> <pre><code>Random random = new Random();\n\nList&lt;Supplier&lt;Weather&gt;&gt; weatherTasks = buildWeatherTasks(random);\nList&lt;Supplier&lt;Quotation&gt;&gt; quotationTasks = buildQuotationTasks(random);\n\nCompletableFuture&lt;Weather&gt;[] weatherCFs = weatherTasks.stream()\n    .map(CompletableFuture::supplyAsync)\n    .toArray(CompletableFuture[]::new);\n\nCompletableFuture&lt;Weather&gt; weatherCF =\n    CompletableFuture.anyOf(weatherCFs)\n        .thenApply(weather -&gt; (Weather) weather);\n\n\nCompletableFuture&lt;Quotation&gt;[] quotationCFS = quotationTasks.stream()\n    .map(CompletableFuture::supplyAsync)\n    .toArray(CompletableFuture[]::new);\n\nCompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(quotationCFS);\n\nCompletableFuture&lt;Quotation&gt; bestQuotationCF = allOf.thenApply(\n    v -&gt; Arrays.stream(quotationCFS)\n        .map(CompletableFuture::join)\n        .min(Comparator.comparing(Quotation::amount))\n        .orElseThrow()\n);\n\nCompletableFuture&lt;Void&gt; done =\nbestQuotationCF.thenCompose(\n    quotation -&gt;\n        weatherCF.thenApply(weather -&gt; new TravelPage(quotation, weather)))\n    .thenAccept(System.out::println);\ndone.join();\n</code></pre>"},{"location":"linux/","title":"Linux","text":""},{"location":"linux/serial_terminal_proxmox/","title":"Setting Up a Serial Terminal in Proxmox","text":"<p>Reference for setting up a serial terminal in proxmox can be found here. Unfortunately this does not cover the process for debian as there is not Upstart init system.</p> <p>To use it with systemd do the following:</p>"},{"location":"linux/serial_terminal_proxmox/#proxmox-host","title":"Proxmox HOST","text":"<pre><code>qm set &lt;VM_ID&gt; -serial0 socket\n</code></pre>"},{"location":"linux/serial_terminal_proxmox/#proxmox-guest-vm","title":"Proxmox GUEST VM","text":"<ul> <li>edit grub</li> </ul> <pre><code>sudo nano /etc/defaults/grub\n</code></pre> <ul> <li>Paste</li> </ul> <pre><code>GRUB_CMDLINE_LINUX_DEFAULT=\"quiet console=tty0 console=ttyS0,115200n8\"\nGRUB_TERMINAL=serial\nGRUB_SERIAL_COMMAND=\"serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1\"\n</code></pre> <ul> <li>update grub</li> </ul> <pre><code>sudo update-grub\n</code></pre> <ul> <li>Create the service</li> </ul> <pre><code>sudo nano /etc/systemd/system/serial-getty@ttyS0.service\n</code></pre> <ul> <li>Paste following content:</li> </ul> <pre><code>[Unit]\nDescription=Serial Getty on ttyS0\nDocumentation=man:agetty(8)\nAfter=systemd-user-sessions.service plymouth-quit-wait.service\nAfter=rc-local.service\n\n[Service]\nExecStart=/sbin/agetty -L 115200 ttyS0 vt102\nRestart=always\nRestartSec=0\nUtmpIdentifier=ttyS0\nTTYPath=/dev/ttyS0\nTTYReset=yes\nTTYVHangup=yes\nKillMode=process\nIgnoreSIGPIPE=no\nSendSIGHUP=yes\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <ul> <li>Reload Systemd,Enable and Start the Service:</li> </ul> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable serial-getty@ttyS0.service\nsudo systemctl start serial-getty@ttyS0.service\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>sudo systemctl status serial-getty@ttyS0.service\n</code></pre> <p>Now you should be able to use xterm.js in proxmox GUI</p>"},{"location":"networking/custom_comain_email-gmail/","title":"Use a custom Domain as your Email Address using Gmail","text":""},{"location":"networking/custom_comain_email-gmail/#email-forwarding-to-gmail","title":"Email forwarding to Gmail","text":"<ol> <li> <p>Log in to your Cloudflare Dashboard and select your zone and click \"Email\" in the left navigation panel.</p> </li> <li> <p>Create a custom email address or your domain (in my case me@example.com) then type in the destination email address (your Gmail address - in my case, username13335@gmail.com).</p> </li> <li> <p>This step will trigger sending a confirmation email to username13335@gmail.com so that they can prove that the destination Inbox is yours. You need to open Gmail and press the verification link.</p> </li> </ol> <p></p> <ol> <li>Then, in the last step, you need to configure your zone MX and SPF DNS records. They will do this automatically for you. Just press \"Add records automatically\".</li> </ol> <p></p> <p>That\u2019s it, Email Routing is now configured, and you can start sending emails to me@example.com and read them at username13335@gmail.com in Gmail.</p> <p></p> <p>All credits to: paulonteri</p>"},{"location":"sap/","title":"SAP Systems","text":""},{"location":"sap/transactions/","title":"Important Transactions","text":"<p>Always use <code>/n</code> as a prefix of a transaction to ensure it opens in a new window.</p> <ul> <li><code>/ndbacockpit</code> opens the dbacockpit where the SQL editor can be used   </li> <li><code>/nse11</code> opens the Abap Dictionary. Enter a table name to find out the columns   </li> <li><code>/nse16</code> opens the Data Browser. When entering a table name and click on \"Table Contents\" and afterwards \"Number of Entries\" it displays the amount of rows for the table   </li> </ul>"}]}